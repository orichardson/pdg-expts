\documentclass{article}

%\input{../model-commands}
\usepackage[margin=1in]{geometry}
\usepackage{mathtools,amssymb,amsfonts}
\usepackage{parskip}

\usepackage{amsthm,thmtools}
	\theoremstyle{plain}
	\newtheorem{theorem}{Theorem}[section]
	\newtheorem{coro}{Corollary}[theorem]
	\newtheorem{prop}[theorem]{Proposition}
	\newtheorem{lemma}[theorem]{Lemma}
	\newtheorem{fact}[theorem]{Fact}
	\newtheorem{conj}[theorem]{Conjecture}
	
	\theoremstyle{definition}
	\declaretheorem[name=Definition,numberwithin=section,qed=$\square$]{defn}
	\declaretheorem[name=Construction,qed=$\square$,sibling=defn]{constr}
	\declaretheorem[qed=$\square$]{example}
	
	\theoremstyle{remark}
	\newtheorem*{remark}{Remark}


\begin{document}
\section{Introduction}
In our first paper, we introduced PDGs, their semantics, and some examples. 
PDGs are able to represent an inconsistent collection of local beliefs; we have argued that doing so allows us to represent important states of knowledge, and hinted that it may allow us to make better decisions and save computation. We now directly address all three issues.

\begin{enumerate}
	\item 
\end{enumerate}

%TODO A collection of examples, show how each is resolved.
%TODO propose a mechanism for resolving things.

\end{document}