#+TITLE: Log
#+LATEX_HEADER: \usepackage{tikzcd}


* TODO LOOK AT THIS LOG EVERY DA
SCHEDULED: <2020-07-24 Fri 09:45 +1d>
:PROPERTIES:
:STYLE:    habit
:LAST_REPEAT: [2020-07-27 Mon 13:16]
:END:
:LOGBOOK:
- State "DONE"       from "TODO"       [2020-07-27 Mon 13:16]
- State "DONE"       from "TODO"       [2020-07-25 Sat 19:19]
- State "DONE"       from "TODO"       [2020-07-23 Thu 19:04]
:END:


I get scared when I see blank pages. I am scared I will write the wrong thing in the wrong place. That the things that I make right now will get in the way of the things I want to make in the future. But I should not be scared. Putting something in the wrong place is something I do all the time. I put things in the wrong place everywhere, a



* TODO [0/9] Writing
** TODO The Computation Done by a PDG
*** TODO The Scheduler
** TODO 3 Classes of attribute Uniqueness
*** TODO ALL-UNIQUE
All Attributes of all tables unique (globally)
*** TODO Attributes in a table unique (local uniquness)
Means that they may or may not be able to be sewn back together in order to form
a global
***

** TODO Plate Models and relationship to 1st order
** TODO :Heuristic:
condense many similar variables into a abstraction and an accessor (imaginary, internal, fast moving state: the index variable)

Intuition: rather having many variables, you invent two new variables (X, i) where the first variable controls the meaning of the second one. The reason for the plate is that

** TODO Three kinds of arrows, different kinds of probabilsitic events
** TODO

* COOL IDEAS TO FOLLOW UP WITH
** Noisy Channel and Imperfect Coding & Guard Variables
Maybe one way to do smoothing about the
[[file:writeups/databases.tex][DB document]]

**

Each belief and concept has a time scale τ (expected time to decay).


A sequence of probability distributions scores according to the degree to which, for every $L$, each probability matrix pᵗ_L(Y | X) converges, while t is in timescale τ_L.

((Instead of a time-scale, (which is global and scheduler dependent), we might also))


- Roughly like a scope. It may be just a partial order, or have weak ordering information, in addition to strict information.
  - specifically, one scope may be a strict subset of another (think: one timescale really long relative to another), but

** A Theme:
Fully interpreted vs partially interpreted functor

| Fully    | Partially                                 | None            |
|----------+-------------------------------------------+-----------------|
| a PDG    | Subset of a PDG (some arrows interpreted) | Qualitative PDG |
| functor  | profuntor                                 | No relationship |
| Function | CPD                                       | No edge         |
| CPD      | Sub-CPD (missing fibers)                  | No edge         |
| Function | Partial Function                          |                 |
| Lax PDG  | Strict PDG                                |                 |


This is because PDGs are the simplest well-behaved objects that incorporate both (1) in-between-ness / convexity, and (2) functions, properly.

    ((They are the basis of probabilistic programming. (Aside: that's why I might not be right about a lot of things; they're so great that I'm holding onto a lot of threads at once. If I can successfully defend all of the threads, I'll be in a good place.))

The reason generalizations are useful is becasue they give a notion of "in-betweenness" that means something more useful.

"a in-betweenness" in pixel space is boring, and not the one that follows the patterns that look like the world. To view distance in that world, you have to train a statstical model to transform you into those coordinates before you can properly evaluate betweenness.


Another theme of PDGS:

**PROGRAMS DO NOT NEED TO BE SAFE BY CONSTRUCTION**

Safety is not guaranteed before things are run. This is too good to be true, unless you know a whole lot about what is happening.

But there are lots of blurred time around "runtime" anyway, and safety is about protecting one runtime from another..

 - Protect code (executed) from


** A Type Logarithm
** Independence is holding graphical models back.

If we want to model a dependent sum, in which the values of one variable themselves, are dependent on the other, it's easy to replace

\[ (i : I) \to X_i \]
   (i : I) → Xᵢ      ( or ∏ᵢ Xᵢ )

         with

   I  → ⊎ᵢ Xᵢ

 resulting in some loss of preccision, but this is standard. The "disjoint" bit is necessary to avoid acicdentally encoding equations, which create ambiguity if we care about distinguishing ~inl(x)~ and ~inl(y)~, for instance \gamma
**
